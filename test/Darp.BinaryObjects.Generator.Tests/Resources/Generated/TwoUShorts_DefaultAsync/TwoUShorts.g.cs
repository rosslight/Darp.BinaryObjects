// <auto-generated/>
#nullable enable

using BinaryPrimitives = global::System.Buffers.Binary.BinaryPrimitives;
using NotNullWhenAttribute = global::System.Diagnostics.CodeAnalysis.NotNullWhenAttribute;

/// <remarks> <list type="table">
/// <item> <term><b>Field</b></term> <description><b>Byte Length</b></description> </item>
/// <item> <term><see cref="ValueOne"/></term> <description>2</description> </item>
/// <item> <term><see cref="ValueTwo"/></term> <description>2</description> </item>
/// <item> <term> --- </term> <description>4</description> </item>
/// </list> </remarks>
public sealed partial record TwoUShorts : global::Darp.BinaryObjects.IWritable, global::Darp.BinaryObjects.ISpanReadable<TwoUShorts>
{
    /// <inheritdoc />
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public int GetByteCount() => 4;

    /// <inheritdoc />
    public bool TryWriteLittleEndian(global::System.Span<byte> destination) => TryWriteLittleEndian(destination, out _);
    /// <inheritdoc />
    public bool TryWriteLittleEndian(global::System.Span<byte> destination, out int bytesWritten)
    {
        bytesWritten = 0;

        if (destination.Length < 4)
            return false;
        BinaryPrimitives.WriteUInt16LittleEndian(destination[0..], this.ValueOne);
        BinaryPrimitives.WriteUInt16LittleEndian(destination[2..], this.ValueTwo);
        bytesWritten += 4;

        return true;
    }
    /// <inheritdoc />
    public bool TryWriteBigEndian(global::System.Span<byte> destination) => TryWriteBigEndian(destination, out _);
    /// <inheritdoc />
    public bool TryWriteBigEndian(global::System.Span<byte> destination, out int bytesWritten)
    {
        bytesWritten = 0;

        if (destination.Length < 4)
            return false;
        BinaryPrimitives.WriteUInt16BigEndian(destination[0..], this.ValueOne);
        BinaryPrimitives.WriteUInt16BigEndian(destination[2..], this.ValueTwo);
        bytesWritten += 4;

        return true;
    }

    /// <inheritdoc />
    public static bool TryReadLittleEndian(global::System.ReadOnlySpan<byte> source, [NotNullWhen(true)] out TwoUShorts? value) => TryReadLittleEndian(source, out value, out _);
    /// <inheritdoc />
    public static bool TryReadLittleEndian(global::System.ReadOnlySpan<byte> source, [NotNullWhen(true)] out TwoUShorts? value, out int bytesRead)
    {
        bytesRead = 0;
        value = default;

        if (source.Length < 4)
            return false;
        var ___readValueOne = BinaryPrimitives.ReadUInt16LittleEndian(source[0..]);
        var ___readValueTwo = BinaryPrimitives.ReadUInt16LittleEndian(source[2..]);
        bytesRead += 4;

        value = new TwoUShorts(___readValueOne, ___readValueTwo);
        return true;
    }
    /// <inheritdoc />
    public static bool TryReadBigEndian(global::System.ReadOnlySpan<byte> source, [NotNullWhen(true)] out TwoUShorts? value) => TryReadBigEndian(source, out value, out _);
    /// <inheritdoc />
    public static bool TryReadBigEndian(global::System.ReadOnlySpan<byte> source, [NotNullWhen(true)] out TwoUShorts? value, out int bytesRead)
    {
        bytesRead = 0;
        value = default;

        if (source.Length < 4)
            return false;
        var ___readValueOne = BinaryPrimitives.ReadUInt16BigEndian(source[0..]);
        var ___readValueTwo = BinaryPrimitives.ReadUInt16BigEndian(source[2..]);
        bytesRead += 4;

        value = new TwoUShorts(___readValueOne, ___readValueTwo);
        return true;
    }
}
