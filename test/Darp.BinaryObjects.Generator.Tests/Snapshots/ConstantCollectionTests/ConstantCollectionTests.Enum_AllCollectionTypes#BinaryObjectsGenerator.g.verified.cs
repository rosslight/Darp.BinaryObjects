//HintName: BinaryObjectsGenerator.g.cs
// <auto-generated/>
#nullable enable

/// <remarks> <list type="table">
/// <item> <term><b>Field</b></term> <description><b>Byte Length</b></description> </item>
/// <item> <term><see cref="ValueMemory"/></term> <description>4 * 2</description> </item>
/// <item> <term><see cref="ValueArray"/></term> <description>4 * 2</description> </item>
/// <item> <term><see cref="ValueList"/></term> <description>4 * 2</description> </item>
/// <item> <term> --- </term> <description>24</description> </item>
/// </list> </remarks>
[global::Darp.BinaryObjects.BinaryConstant(24)]
public sealed partial record TestObject : global::Darp.BinaryObjects.IBinaryObject<TestObject>
{
    /// <inheritdoc />
    [global::System.Diagnostics.Contracts.Pure]
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public int GetByteCount() => 24;

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteLittleEndian(global::System.Span<byte> destination) => TryWriteLittleEndian(destination, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteLittleEndian(global::System.Span<byte> destination, out int bytesWritten)
    {
        bytesWritten = 0;

        if (destination.Length < 24)
            return false;
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt32EnumSpanLittleEndian<IntEnum>(destination[0..8], this.ValueMemory.Span);
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt32EnumSpanLittleEndian<IntEnum>(destination[8..16], this.ValueArray);
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt32EnumListLittleEndian<IntEnum>(destination[16..24], this.ValueList);
        bytesWritten += 24;

        return true;
    }
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteBigEndian(global::System.Span<byte> destination) => TryWriteBigEndian(destination, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteBigEndian(global::System.Span<byte> destination, out int bytesWritten)
    {
        bytesWritten = 0;

        if (destination.Length < 24)
            return false;
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt32EnumSpanBigEndian<IntEnum>(destination[0..8], this.ValueMemory.Span);
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt32EnumSpanBigEndian<IntEnum>(destination[8..16], this.ValueArray);
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt32EnumListBigEndian<IntEnum>(destination[16..24], this.ValueList);
        bytesWritten += 24;

        return true;
    }

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadLittleEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TestObject? value) => TryReadLittleEndian(source, out value, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadLittleEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TestObject? value, out int bytesRead)
    {
        bytesRead = 0;
        value = default;

        if (source.Length < 24)
            return false;
        var ___readValueMemory = global::Darp.BinaryObjects.Generated.Utilities.ReadInt32EnumArrayLittleEndian<IntEnum>(source[0..8], out _);
        var ___readValueArray = global::Darp.BinaryObjects.Generated.Utilities.ReadInt32EnumArrayLittleEndian<IntEnum>(source[8..16], out _);
        var ___readValueList = global::Darp.BinaryObjects.Generated.Utilities.ReadInt32EnumListLittleEndian<IntEnum>(source[16..24], out _);
        bytesRead += 24;

        value = new TestObject(___readValueMemory, ___readValueArray, ___readValueList);
        return true;
    }
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadBigEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TestObject? value) => TryReadBigEndian(source, out value, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadBigEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TestObject? value, out int bytesRead)
    {
        bytesRead = 0;
        value = default;

        if (source.Length < 24)
            return false;
        var ___readValueMemory = global::Darp.BinaryObjects.Generated.Utilities.ReadInt32EnumArrayBigEndian<IntEnum>(source[0..8], out _);
        var ___readValueArray = global::Darp.BinaryObjects.Generated.Utilities.ReadInt32EnumArrayBigEndian<IntEnum>(source[8..16], out _);
        var ___readValueList = global::Darp.BinaryObjects.Generated.Utilities.ReadInt32EnumListBigEndian<IntEnum>(source[16..24], out _);
        bytesRead += 24;

        value = new TestObject(___readValueMemory, ___readValueArray, ___readValueList);
        return true;
    }
}

namespace Darp.BinaryObjects.Generated
{
    using Darp.BinaryObjects;
    using System;
    using System.Buffers.Binary;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;

    /// <summary>Helper methods used by generated BinaryObjects.</summary>
    [GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    file static class Utilities
    {
        /// <summary> Writes a <c>ReadOnlySpan&lt;TEnum&gt;</c> with a <c>maxElementLength</c> to the destination, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int WriteInt32EnumSpanLittleEndian<TEnum>(Span<byte> destination, ReadOnlySpan<TEnum> value)
            where TEnum : unmanaged, Enum
        {
            var length = Math.Min(value.Length, destination.Length / 4);
            if (!BitConverter.IsLittleEndian)
            {
                ReadOnlySpan<int> reinterpretedValue = MemoryMarshal.Cast<TEnum, int>(value);
                Span<int> reinterpretedDestination = MemoryMarshal.Cast<byte, int>(destination);
                BinaryPrimitives.ReverseEndianness(reinterpretedValue[..length], reinterpretedDestination);
                return length * 4;
            }
            MemoryMarshal.Cast<TEnum, byte>(value[..length]).CopyTo(destination);
            return length * 4;
        }
        /// <summary> Writes a <c>ReadOnlySpan&lt;TEnum&gt;</c> with a <c>maxElementLength</c> to the destination, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int WriteInt32EnumSpanBigEndian<TEnum>(Span<byte> destination, ReadOnlySpan<TEnum> value)
            where TEnum : unmanaged, Enum
        {
            var length = Math.Min(value.Length, destination.Length / 4);
            if (BitConverter.IsLittleEndian)
            {
                ReadOnlySpan<int> reinterpretedValue = MemoryMarshal.Cast<TEnum, int>(value);
                Span<int> reinterpretedDestination = MemoryMarshal.Cast<byte, int>(destination);
                BinaryPrimitives.ReverseEndianness(reinterpretedValue[..length], reinterpretedDestination);
                return length * 4;
            }
            MemoryMarshal.Cast<TEnum, byte>(value[..length]).CopyTo(destination);
            return length * 4;
        }
        /// <summary> Reads a <c>TEnum[]</c> from the given source, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TEnum[] ReadInt32EnumArrayLittleEndian<TEnum>(ReadOnlySpan<byte> source, out int bytesRead)
            where TEnum : unmanaged, Enum
        {
            var array = MemoryMarshal.Cast<byte, TEnum>(source).ToArray();
            if (!BitConverter.IsLittleEndian)
            {
                var reinterpretedArray = MemoryMarshal.Cast<TEnum, int>(array);
                BinaryPrimitives.ReverseEndianness(reinterpretedArray, reinterpretedArray);
            }
            bytesRead = array.Length * 4;
            return array;
        }
        /// <summary> Reads a <c>TEnum[]</c> from the given source, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TEnum[] ReadInt32EnumArrayBigEndian<TEnum>(ReadOnlySpan<byte> source, out int bytesRead)
            where TEnum : unmanaged, Enum
        {
            var array = MemoryMarshal.Cast<byte, TEnum>(source).ToArray();
            if (BitConverter.IsLittleEndian)
            {
                var reinterpretedArray = MemoryMarshal.Cast<TEnum, int>(array);
                BinaryPrimitives.ReverseEndianness(reinterpretedArray, reinterpretedArray);
            }
            bytesRead = array.Length * 4;
            return array;
        }
        /// <summary> Writes a <c>List&lt;TEnum&gt;</c> with a <c>maxElementLength</c> to the destination, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int WriteInt32EnumListLittleEndian<TEnum>(Span<byte> destination, List<TEnum> value)
            where TEnum : unmanaged, Enum
        {
            return WriteInt32EnumSpanLittleEndian<TEnum>(destination, CollectionsMarshal.AsSpan(value));
        }
        /// <summary> Writes a <c>List&lt;TEnum&gt;</c> with a <c>maxElementLength</c> to the destination, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int WriteInt32EnumListBigEndian<TEnum>(Span<byte> destination, List<TEnum> value)
            where TEnum : unmanaged, Enum
        {
            return WriteInt32EnumSpanBigEndian<TEnum>(destination, CollectionsMarshal.AsSpan(value));
        }
        /// <summary> Reads a <c>List&lt;TEnum&gt;</c> from the given source, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static List<TEnum> ReadInt32EnumListLittleEndian<TEnum>(ReadOnlySpan<byte> source, out int bytesRead)
            where TEnum : unmanaged, Enum
        {
            ReadOnlySpan<TEnum> span = MemoryMarshal.Cast<byte, TEnum>(source);
            var list = new List<TEnum>(span.Length);
            list.AddRange(span);
            if (!BitConverter.IsLittleEndian)
            {
                var reinterpretedList = MemoryMarshal.Cast<TEnum, int>(CollectionsMarshal.AsSpan(list));
                BinaryPrimitives.ReverseEndianness(reinterpretedList, reinterpretedList);
            }
            bytesRead = list.Count * 4;
            return list;
        }
        /// <summary> Reads a <c>List&lt;TEnum&gt;</c> from the given source, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static List<TEnum> ReadInt32EnumListBigEndian<TEnum>(ReadOnlySpan<byte> source, out int bytesRead)
            where TEnum : unmanaged, Enum
        {
            ReadOnlySpan<TEnum> span = MemoryMarshal.Cast<byte, TEnum>(source);
            var list = new List<TEnum>(span.Length);
            list.AddRange(span);
            if (BitConverter.IsLittleEndian)
            {
                var reinterpretedList = MemoryMarshal.Cast<TEnum, int>(CollectionsMarshal.AsSpan(list));
                BinaryPrimitives.ReverseEndianness(reinterpretedList, reinterpretedList);
            }
            bytesRead = list.Count * 4;
            return list;
        }
    }
}
