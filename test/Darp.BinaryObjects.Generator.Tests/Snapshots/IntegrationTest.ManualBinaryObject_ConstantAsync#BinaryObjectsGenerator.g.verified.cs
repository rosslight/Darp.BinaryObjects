//HintName: BinaryObjectsGenerator.g.cs
// <auto-generated/>
#nullable enable

/// <remarks> <list type="table">
/// <item> <term><b>Field</b></term> <description><b>Byte Length</b></description> </item>
/// <item> <term><see cref="Value"/></term> <description>1</description> </item>
/// <item> <term><see cref="Values"/></term> <description>1 * 2</description> </item>
/// <item> <term><see cref="Length"/></term> <description>1</description> </item>
/// <item> <term><see cref="LengthValues"/></term> <description>1 * <see cref="Length"/></description> </item>
/// <item> <term><see cref="RemainingValue"/></term> <description>1 * n</description> </item>
/// <item> <term> --- </term> <description>4 + 1 * <see cref="Length"/> + 1 * n</description> </item>
/// </list> </remarks>
public sealed partial record UnlimitedWithMinLength : global::Darp.BinaryObjects.IBinaryObject<UnlimitedWithMinLength>
{
    /// <inheritdoc />
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public int GetByteCount() => 4 + 1 * this.Length + 1 * this.RemainingValue.Count;

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteLittleEndian(global::System.Span<byte> destination) => TryWriteLittleEndian(destination, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteLittleEndian(global::System.Span<byte> destination, out int bytesWritten)
    {
        bytesWritten = 0;

        if (destination.Length < 4)
            return false;
        global::Darp.BinaryObjects.Generated.Utilities.WriteBinaryObjectLittleEndian(destination[0..1], this.Value);
        global::Darp.BinaryObjects.Generated.Utilities.WriteBinaryObjectSpanLittleEndian<ManualConstantObject>(destination.Slice(1, 2), this.Values);
        global::Darp.BinaryObjects.Generated.Utilities.WriteUInt8(destination[3..4], this.Length);
        bytesWritten += 4;

        if (destination.Length < bytesWritten + this.Length)
            return false;
        global::Darp.BinaryObjects.Generated.Utilities.WriteBinaryObjectSpanLittleEndian<ManualConstantObject>(destination.Slice(4, this.Length), this.LengthValues);
        bytesWritten += this.Length;

        bytesWritten += global::Darp.BinaryObjects.Generated.Utilities.WriteBinaryObjectListLittleEndian<ManualConstantObject>(destination[4..], this.RemainingValue);

        return true;
    }
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteBigEndian(global::System.Span<byte> destination) => TryWriteBigEndian(destination, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteBigEndian(global::System.Span<byte> destination, out int bytesWritten)
    {
        bytesWritten = 0;

        if (destination.Length < 4)
            return false;
        global::Darp.BinaryObjects.Generated.Utilities.WriteBinaryObjectBigEndian(destination[0..1], this.Value);
        global::Darp.BinaryObjects.Generated.Utilities.WriteBinaryObjectSpanBigEndian<ManualConstantObject>(destination.Slice(1, 2), this.Values);
        global::Darp.BinaryObjects.Generated.Utilities.WriteUInt8(destination[3..4], this.Length);
        bytesWritten += 4;

        if (destination.Length < bytesWritten + this.Length)
            return false;
        global::Darp.BinaryObjects.Generated.Utilities.WriteBinaryObjectSpanBigEndian<ManualConstantObject>(destination.Slice(4, this.Length), this.LengthValues);
        bytesWritten += this.Length;

        bytesWritten += global::Darp.BinaryObjects.Generated.Utilities.WriteBinaryObjectListBigEndian<ManualConstantObject>(destination[4..], this.RemainingValue);

        return true;
    }

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadLittleEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out UnlimitedWithMinLength? value) => TryReadLittleEndian(source, out value, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadLittleEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out UnlimitedWithMinLength? value, out int bytesRead)
    {
        bytesRead = 0;
        value = default;

        if (source.Length < 4)
            return false;
        var ___readValue = global::Darp.BinaryObjects.Generated.Utilities.ReadBinaryObjectLittleEndian<ManualConstantObject>(source[0..1]);
        var ___readValues = global::Darp.BinaryObjects.Generated.Utilities.ReadBinaryObjectArrayLittleEndian<ManualConstantObject>(source[1..3], 1, out _);
        var ___readLength = global::Darp.BinaryObjects.Generated.Utilities.ReadUInt8(source[3..4]);
        bytesRead += 4;

        if (source.Length < bytesRead + ___readLength)
            return false;
        var ___readLengthValues = global::Darp.BinaryObjects.Generated.Utilities.ReadBinaryObjectArrayLittleEndian<ManualConstantObject>(source.Slice(4, ___readLength), 1, out _);
        bytesRead += ___readLength;

        var ___readRemainingValue = global::Darp.BinaryObjects.Generated.Utilities.ReadBinaryObjectListLittleEndian<ManualConstantObject>(source.Slice(4), 1, out int ___bytesReadRemainingValue);
        bytesRead += ___bytesReadRemainingValue;

        value = new UnlimitedWithMinLength(___readValue, ___readValues, ___readLength, ___readLengthValues, ___readRemainingValue);
        return true;
    }
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadBigEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out UnlimitedWithMinLength? value) => TryReadBigEndian(source, out value, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadBigEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out UnlimitedWithMinLength? value, out int bytesRead)
    {
        bytesRead = 0;
        value = default;

        if (source.Length < 4)
            return false;
        var ___readValue = global::Darp.BinaryObjects.Generated.Utilities.ReadBinaryObjectBigEndian<ManualConstantObject>(source[0..1]);
        var ___readValues = global::Darp.BinaryObjects.Generated.Utilities.ReadBinaryObjectArrayBigEndian<ManualConstantObject>(source[1..3], 1, out _);
        var ___readLength = global::Darp.BinaryObjects.Generated.Utilities.ReadUInt8(source[3..4]);
        bytesRead += 4;

        if (source.Length < bytesRead + ___readLength)
            return false;
        var ___readLengthValues = global::Darp.BinaryObjects.Generated.Utilities.ReadBinaryObjectArrayBigEndian<ManualConstantObject>(source.Slice(4, ___readLength), 1, out _);
        bytesRead += ___readLength;

        var ___readRemainingValue = global::Darp.BinaryObjects.Generated.Utilities.ReadBinaryObjectListBigEndian<ManualConstantObject>(source.Slice(4), 1, out int ___bytesReadRemainingValue);
        bytesRead += ___bytesReadRemainingValue;

        value = new UnlimitedWithMinLength(___readValue, ___readValues, ___readLength, ___readLengthValues, ___readRemainingValue);
        return true;
    }
}

namespace Darp.BinaryObjects.Generated
{
    using Darp.BinaryObjects;
    using System;
    using System.Buffers.Binary;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;

    /// <summary>Helper methods used by generated BinaryObjects.</summary>
    [GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    file static class Utilities
    {
        /// <summary> Writes a <c>byte</c> to the destination </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void WriteUInt8(Span<byte> destination, byte value)
        {
            destination[0] = value;
        }
        /// <summary> Reads a <c>byte</c> from the given source </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte ReadUInt8(ReadOnlySpan<byte> source)
        {
            return source[0];
        }
        /// <summary> Writes a <c>T</c> to the destination </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void WriteBinaryObjectLittleEndian<T>(Span<byte> destination, T value)
            where T : IBinaryWritable
        {
            if (!value.TryWriteLittleEndian(destination))
                throw new ArgumentOutOfRangeException(nameof(value));
        }
        /// <summary> Writes a <c>T</c> to the destination </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void WriteBinaryObjectBigEndian<T>(Span<byte> destination, T value)
            where T : IBinaryWritable
        {
            if (!value.TryWriteBigEndian(destination))
                throw new ArgumentOutOfRangeException(nameof(value));
        }
        /// <summary> Reads a <c>T</c> from the given source, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T ReadBinaryObjectLittleEndian<T>(ReadOnlySpan<byte> source)
            where T : IBinaryReadable<T>
        {
            if (!T.TryReadLittleEndian(source, out var value))
                throw new ArgumentOutOfRangeException(nameof(source));
            return value;
        }
        /// <summary> Reads a <c>T</c> from the given source, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T ReadBinaryObjectBigEndian<T>(ReadOnlySpan<byte> source)
            where T : IBinaryReadable<T>
        {
            if (!T.TryReadBigEndian(source, out var value))
                throw new ArgumentOutOfRangeException(nameof(source));
            return value;
        }
        /// <summary> Writes a <c>ReadOnlySpan&lt;T&gt;</c> with a <c>maxElementLength</c> to the destination, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int WriteBinaryObjectSpanLittleEndian<T>(Span<byte> destination, ReadOnlySpan<T> value)
            where T : IBinaryWritable
        {
            if (value.Length == 0)
                return 0;
            var elementLength = value[0].GetByteCount();
            var maxNumberOfElements = destination.Length / elementLength;
            for (var i = 0; i < maxNumberOfElements; i++)
            {
                if (!value[i].TryWriteLittleEndian(destination.Slice(i * elementLength, elementLength)))
                    throw new ArgumentException($"Could not write {typeof(T).Name} to destination");
            }
            return elementLength * maxNumberOfElements;
        }
        /// <summary> Writes a <c>ReadOnlySpan&lt;T&gt;</c> with a <c>maxElementLength</c> to the destination, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int WriteBinaryObjectSpanBigEndian<T>(Span<byte> destination, ReadOnlySpan<T> value)
            where T : IBinaryWritable
        {
            if (value.Length == 0)
                return 0;
            var elementLength = value[0].GetByteCount();
            var maxNumberOfElements = destination.Length / elementLength;
            for (var i = 0; i < maxNumberOfElements; i++)
            {
                if (!value[i].TryWriteBigEndian(destination.Slice(i * elementLength, elementLength)))
                    throw new ArgumentException($"Could not write {typeof(T).Name} to destination");
            }
            return elementLength * maxNumberOfElements;
        }
        /// <summary> Reads a <c>T[]</c> from the given source, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T[] ReadBinaryObjectArrayLittleEndian<T>(ReadOnlySpan<byte> source, int elementLength, out int bytesRead)
            where T : IBinaryReadable<T>
        {
            var numberOfElements = source.Length / elementLength;
            var array = new T[numberOfElements];
            for (var i = 0; i < numberOfElements; i++)
            {
                if (!T.TryReadLittleEndian(source.Slice(i * elementLength, elementLength), out T? value, out var tempBytesRead))
                    throw new ArgumentException($"Could not read {typeof(T).Name} from source");
                array[i] = value;
            }
            bytesRead = numberOfElements * elementLength;
            return array;
        }
        /// <summary> Reads a <c>T[]</c> from the given source, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T[] ReadBinaryObjectArrayBigEndian<T>(ReadOnlySpan<byte> source, int elementLength, out int bytesRead)
            where T : IBinaryReadable<T>
        {
            var numberOfElements = source.Length / elementLength;
            var array = new T[numberOfElements];
            for (var i = 0; i < numberOfElements; i++)
            {
                if (!T.TryReadBigEndian(source.Slice(i * elementLength, elementLength), out T? value, out var tempBytesRead))
                    throw new ArgumentException($"Could not read {typeof(T).Name} from source");
                array[i] = value;
            }
            bytesRead = numberOfElements * elementLength;
            return array;
        }
        /// <summary> Writes a <c>List&lt;T&gt;</c> with a <c>maxElementLength</c> to the destination, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int WriteBinaryObjectListLittleEndian<T>(Span<byte> destination, List<T> value)
            where T : IBinaryWritable
        {
            return WriteBinaryObjectSpanLittleEndian<T>(destination, CollectionsMarshal.AsSpan(value));
        }
        /// <summary> Writes a <c>List&lt;T&gt;</c> with a <c>maxElementLength</c> to the destination, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int WriteBinaryObjectListBigEndian<T>(Span<byte> destination, List<T> value)
            where T : IBinaryWritable
        {
            return WriteBinaryObjectSpanBigEndian<T>(destination, CollectionsMarshal.AsSpan(value));
        }
        /// <summary> Reads a <c>List&lt;T&gt;</c> from the given source, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static List<T> ReadBinaryObjectListLittleEndian<T>(ReadOnlySpan<byte> source, int elementLength, out int bytesRead)
            where T : IBinaryReadable<T>
        {
            var numberOfElements = source.Length / elementLength;
            var array = new List<T>(numberOfElements);
            for (var i = 0; i < numberOfElements; i++)
            {
                if (!T.TryReadLittleEndian(source.Slice(i * elementLength, elementLength), out T? value, out var tempBytesRead))
                    throw new ArgumentException($"Could not read {typeof(T).Name} from source");
                array[i] = value;
            }
            bytesRead = numberOfElements * elementLength;
            return array;
        }
        /// <summary> Reads a <c>List&lt;T&gt;</c> from the given source, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static List<T> ReadBinaryObjectListBigEndian<T>(ReadOnlySpan<byte> source, int elementLength, out int bytesRead)
            where T : IBinaryReadable<T>
        {
            var numberOfElements = source.Length / elementLength;
            var array = new List<T>(numberOfElements);
            for (var i = 0; i < numberOfElements; i++)
            {
                if (!T.TryReadBigEndian(source.Slice(i * elementLength, elementLength), out T? value, out var tempBytesRead))
                    throw new ArgumentException($"Could not read {typeof(T).Name} from source");
                array[i] = value;
            }
            bytesRead = numberOfElements * elementLength;
            return array;
        }
    }
}
