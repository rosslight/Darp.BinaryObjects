//HintName: BinaryObjectsGenerator.g.cs
// <auto-generated/>
#nullable enable

/// <remarks> <list type="table">
/// <item> <term><b>Field</b></term> <description><b>Byte Length</b></description> </item>
/// <item> <term><see cref="Value1"/></term> <description>4</description> </item>
/// <item> <term><see cref="Value2"/></term> <description>1</description> </item>
/// <item> <term><see cref="Value3"/></term> <description>8</description> </item>
/// <item> <term> --- </term> <description>13</description> </item>
/// </list> </remarks>
public sealed partial record OneByteEnum : global::Darp.BinaryObjects.IWritable, global::Darp.BinaryObjects.ISpanReadable<OneByteEnum>
{
    /// <inheritdoc />
    [global::System.Diagnostics.Contracts.Pure]
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public int GetByteCount() => 13;

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteLittleEndian(global::System.Span<byte> destination) => TryWriteLittleEndian(destination, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteLittleEndian(global::System.Span<byte> destination, out int bytesWritten)
    {
        bytesWritten = 0;

        if (destination.Length < 13)
            return false;
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt32LittleEndian(destination[0..], (int) this.Value1);
        global::Darp.BinaryObjects.Generated.Utilities.WriteUInt8(destination[4..], (byte) this.Value2);
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt64LittleEndian(destination[5..], (long) this.Value3);
        bytesWritten += 13;

        return true;
    }
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteBigEndian(global::System.Span<byte> destination) => TryWriteBigEndian(destination, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public bool TryWriteBigEndian(global::System.Span<byte> destination, out int bytesWritten)
    {
        bytesWritten = 0;

        if (destination.Length < 13)
            return false;
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt32BigEndian(destination[0..], (int) this.Value1);
        global::Darp.BinaryObjects.Generated.Utilities.WriteUInt8(destination[4..], (byte) this.Value2);
        global::Darp.BinaryObjects.Generated.Utilities.WriteInt64BigEndian(destination[5..], (long) this.Value3);
        bytesWritten += 13;

        return true;
    }

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadLittleEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out OneByteEnum? value) => TryReadLittleEndian(source, out value, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadLittleEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out OneByteEnum? value, out int bytesRead)
    {
        bytesRead = 0;
        value = default;

        if (source.Length < 13)
            return false;
        var ___readValue1 = (DefaultEnum) global::Darp.BinaryObjects.Generated.Utilities.ReadInt32LittleEndian(source[0..]);
        var ___readValue2 = (ByteEnum) global::Darp.BinaryObjects.Generated.Utilities.ReadUInt8(source[4..]);
        var ___readValue3 = (LongEnum) global::Darp.BinaryObjects.Generated.Utilities.ReadInt64LittleEndian(source[5..]);
        bytesRead += 13;

        value = new OneByteEnum(___readValue1, ___readValue2, ___readValue3);
        return true;
    }
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadBigEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out OneByteEnum? value) => TryReadBigEndian(source, out value, out _);
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    public static bool TryReadBigEndian(global::System.ReadOnlySpan<byte> source, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out OneByteEnum? value, out int bytesRead)
    {
        bytesRead = 0;
        value = default;

        if (source.Length < 13)
            return false;
        var ___readValue1 = (DefaultEnum) global::Darp.BinaryObjects.Generated.Utilities.ReadInt32BigEndian(source[0..]);
        var ___readValue2 = (ByteEnum) global::Darp.BinaryObjects.Generated.Utilities.ReadUInt8(source[4..]);
        var ___readValue3 = (LongEnum) global::Darp.BinaryObjects.Generated.Utilities.ReadInt64BigEndian(source[5..]);
        bytesRead += 13;

        value = new OneByteEnum(___readValue1, ___readValue2, ___readValue3);
        return true;
    }
}

namespace Darp.BinaryObjects.Generated
{
    using System;
    using System.Buffers.Binary;
    using System.CodeDom.Compiler;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;

    /// <summary>Helper methods used by generated BinaryObjects.</summary>
    [GeneratedCodeAttribute("Darp.BinaryObjects.Generator", "GeneratorVersion")]
    file static class Utilities
    {
        /// <summary> Writes a <c>byte</c> to the destination </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void WriteUInt8(Span<byte> destination, byte value)
        {
            destination[0] = value;
        }
        /// <summary> Reads a <c>byte</c> from the given source </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte ReadUInt8(ReadOnlySpan<byte> source)
        {
            return source[0];
        }
        /// <summary> Writes a <c>int</c> to the destination </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void WriteInt32LittleEndian(Span<byte> destination, int value)
        {
            BinaryPrimitives.WriteInt32LittleEndian(destination, value);
        }
        /// <summary> Writes a <c>int</c> to the destination </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void WriteInt32BigEndian(Span<byte> destination, int value)
        {
            BinaryPrimitives.WriteInt32BigEndian(destination, value);
        }
        /// <summary> Reads a <c>int</c> from the given source, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ReadInt32LittleEndian(ReadOnlySpan<byte> source)
        {
            return BinaryPrimitives.ReadInt32LittleEndian(source);
        }
        /// <summary> Reads a <c>int</c> from the given source, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ReadInt32BigEndian(ReadOnlySpan<byte> source)
        {
            return BinaryPrimitives.ReadInt32BigEndian(source);
        }
        /// <summary> Writes a <c>long</c> to the destination </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void WriteInt64LittleEndian(Span<byte> destination, long value)
        {
            BinaryPrimitives.WriteInt64LittleEndian(destination, value);
        }
        /// <summary> Writes a <c>long</c> to the destination </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void WriteInt64BigEndian(Span<byte> destination, long value)
        {
            BinaryPrimitives.WriteInt64BigEndian(destination, value);
        }
        /// <summary> Reads a <c>long</c> from the given source, as LittleEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long ReadInt64LittleEndian(ReadOnlySpan<byte> source)
        {
            return BinaryPrimitives.ReadInt64LittleEndian(source);
        }
        /// <summary> Reads a <c>long</c> from the given source, as BigEndian </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long ReadInt64BigEndian(ReadOnlySpan<byte> source)
        {
            return BinaryPrimitives.ReadInt64BigEndian(source);
        }
    }
}
